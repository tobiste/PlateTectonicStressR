---
title: "4. Circular statistics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{4. Circular statistics}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette teaches you how to retrieve the mean direction of stress 
datasets. 

```{r setup, echo=TRUE}
library(tectonicr)
library(ggplot2) # load ggplot library
```

## Mean direction
Directional data is $\pi$-periodical. 
Thus, for the calculation of mean, the average of 35 and 355$^{\circ}$ 
should be 15 instead of 195$^{\circ}$. 
**tectonicr** provides the circular mean (`circular_mean()`) and the 
quasi-median (`circular_median()`) as metrics to describe average direction:

```{r mean, echo=TRUE}
data("san_andreas")
circular_mean(san_andreas$azi)
circular_median(san_andreas$azi)
```

## Quality weighted mean direction
Because the stress data is heteroscedastic, the data with less precise 
direction should have less impact on the final mean direction The weighted 
mean or quasi-median uses the reported measurements weighted 
by the inverse of the uncertainties:
```{r weighted, echo=TRUE}
circular_mean(san_andreas$azi, 1 / san_andreas$unc)
circular_median(san_andreas$azi, 1 / san_andreas$unc)
```
The spread of directional data can be expressed by the standard deviation (for 
the mean) or the quasi-interquartile range (for the median):
```{r weighted_spread, echo=TRUE}
circular_sd(san_andreas$azi, 1 / san_andreas$unc) # standard deviation
circular_IQR(san_andreas$azi, 1 / san_andreas$unc) # interquartile range
```


## Statistics in the Pole of Rotation (PoR) reference frame
Because the $\sigma_{SHmax}$ orientations are subjected to angular distortions in the geographical coordinate system, it is recommended to express statistical parameters using the transformed orientations of the PoR reference frame. 
```{r por, echo=TRUE}
data("cpm_models")
por <- equivalent_rotation(subset(cpm_models, model == "NNR-MORVEL56"), "na", "pa")
san_andreas.por <- PoR_shmax(san_andreas, por, type = "right")
```


```{r por_stats, echo=TRUE}
circular_mean(san_andreas.por$azi.PoR, 1 / san_andreas$unc)
circular_sd(san_andreas.por$azi.PoR, 1 / san_andreas$unc)

circular_median(san_andreas.por$azi.PoR, 1 / san_andreas$unc)
circular_IQR(san_andreas.por$azi.PoR, 1 / san_andreas$unc)
```

## Rose diagram
**tectonicr** offers a rose diagram, i.e. histogram for angular data. 
```{r rose1, echo=TRUE}
rose(san_andreas$azi, weights = 1 / san_andreas$unc, col = "grey", main = "North pole")
```

```{r rose2, echo=TRUE}
rose(san_andreas.por$azi, weights = 1 / san_andreas$unc, col = "grey", main = "PoR")
```


## Statistical tests
### Test for random distribution
Uniformly distributed orientation can be described by the von Mises distribution
(Mardia and Jupp, 1999). 
If the directions are distributed randomly can be tested with the Rayleigh Test:
```{r random, echo=TRUE}
rayleigh_test(san_andreas.por$azi.PoR)
```
Here, the test rejects the Null Hypothesis (`statistic > p.value`). Thus the $\sigma_{SHmax}$ directions have a preferred orientation.

Alternative statistical tests for circular uniformity are `kuiper_test()` and `watson_test()`.
Read `help()` for more details...


## Test for goodness-of-fit
Assuming a von Mises Distribution (circular normal distribution) of the orientation data, a $(1-\alpha \%)/100$ confidence interval can be calculated (Mardia and Jupp, 1999):
```{r confidence, echo=TRUE}
confidence_interval(san_andreas.por$azi.PoR, conf.level = 0.95, w = 1 / san_andreas$unc)
```
The prediction for the $\sigma_{SHmax}$ orientation is $135^{\circ}$. Since the prediction lies within the confidence interval, it can be concluded with 95% confidence that the orientations follow the predicted trend of $\sigma_{SHmax}$.

The  (weighted) circular dispersion of the orientation angles around the prediction can be measured by:
```{r dispersion, echo=TRUE}
circular_dispersion(san_andreas.por$azi.PoR, y = 135, w = 1 / san_andreas$unc)
```
The value of the dispersion ranges between 0 and 2.

The standard error and the confidence interval of the calculated circular dispersion can be estimated by bootstrapping via:
```{r dispersion_MLE, echo=TRUE}
circular_dispersion_boot(san_andreas.por$azi.PoR, y = 135, w = 1 / san_andreas$unc, R = 1000)
```


The statistical test for the goodness-of-fit is the (weighted) Rayleigh Test:
```{r rayleigh2, echo=TRUE}
weighted_rayleigh(san_andreas.por$azi.PoR, prd = 135, unc = san_andreas$unc)
```
If the Null Hypothesis is rejected, the alternative, that is the distribution around the prediction, cannot be excluded.

## Interpolation
Spatial interpolation of stress data is based on the aforementioned metrics (the
algorithm is a modified version of the MATLAB script 'stress2grid' by Ziegler and Heidbach (2017).
```{r interpolation, echo=TRUE}
mean_SH <- stress2grid(san_andreas, gridsize = 1, R_range = seq(50, 350, 100))
```

The defaults use quality and inverse distance weighting of the mean, as well as 
a 25% cut-off for the standard deviation. 

The data can now be visualized:  
```{r plot, echo=TRUE, warning=FALSE, message=FALSE, eval=FALSE}
trajectories <- eulerpole_loxodromes(x = por, n = 40, cw = FALSE)
ggplot(mean_SH) +
  borders(fill = "grey80") +
  geom_sf(data = trajectories, lty = 2) +
  geom_spoke(data = san_andreas, aes(lon, lat, angle = deg2rad(90 - azi)), radius = .5, color = "grey30", position = "center_spoke") +
  geom_spoke(aes(lon, lat, angle = deg2rad(90 - azi), alpha = sd, color = mdr), radius = 1, position = "center_spoke", size = 1) +
  coord_sf(xlim = range(san_andreas$lon), ylim = range(san_andreas$lat)) +
  scale_alpha(name = "Standard deviation", range = c(1, .25)) +
  scale_color_continuous(
    type = "viridis",
    limits = c(0, 1),
    name = "Wavelength\n(R-normalized mean distance)",
    breaks = seq(0, 1, .25)
  ) +
  facet_wrap(~R)
```
![](interpolation.png)

The interpolated direction of far apart data points will suffer from distortions
due to the underlying projection. In order to prevent such effects, the 
interpolation can be done in the PoR reference frame where the direction stays 
constant no matter the distance between the data points. Assuming that the 
stress field is sourced by the plate boundary force, the model-based 
interpolation allows more reliable results for areas close to plate boundaries.

```{r interpolation_PoR, eval=FALSE}
mean_SH_PoR <- PoR_stress2grid(san_andreas, PoR = por, gridsize = 1, R_range = seq(50, 350, 100))
```

```{r plot2, echo=TRUE, warning=FALSE, message=FALSE, eval=FALSE}
ggplot(mean_SH_PoR) +
  borders(fill = "grey80") +
  geom_sf(data = trajectories, lty = 2) +
  geom_spoke(data = san_andreas, aes(lon, lat, angle = deg2rad(90 - azi)), radius = .5, color = "grey30", position = "center_spoke") +
  geom_spoke(aes(lon, lat, angle = deg2rad(90 - azi), alpha = sd, color = mdr), radius = 1, position = "center_spoke", size = 1) +
  coord_sf(xlim = range(san_andreas$lon), ylim = range(san_andreas$lat)) +
  scale_alpha(name = "Standard deviation", range = c(1, .25)) +
  scale_color_continuous(
    type = "viridis",
    limits = c(0, 1),
    name = "Wavelength\n(R-normalized mean distance)",
    breaks = seq(0, 1, .25)
  ) +
  facet_wrap(~R)
```
![](interpolation_PoR.png)


# References
Mardia, K. V., and Jupp, P. E. (Eds.). (1999). "Directional Statistics". 
Hoboken, NJ, USA: John Wiley & Sons, Inc. 
doi: 10.1002/9780470316979.
<!--doi: [10.1002/9780470316979](https://doi.org/10.1002/9780470316979).-->

Ziegler, Moritz O., and Oliver Heidbach. 2017. “Manual of the Matlab Script Stress2Grid.” 
GFZ German Research Centre for Geosciences; World Stress Map Technical Report 17-02. 
doi: [10.5880/wsm.2017.002](https://doi.org/10.5880/wsm.2017.002). 
